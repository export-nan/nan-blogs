import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as i,c as b,f as r,b as a,d as e}from"./app-qc_LvvT5.js";const p="/assets/vector-addition-1fDBZX90.png",n={},h=r('<h1 id="线性代数" tabindex="-1"><a class="header-anchor" href="#线性代数" aria-hidden="true">#</a> 线性代数</h1><h1 id="向量" tabindex="-1"><a class="header-anchor" href="#向量" aria-hidden="true">#</a> 向量</h1><h2 id="向量-vectors-是一个点指向另一个点的方向" tabindex="-1"><a class="header-anchor" href="#向量-vectors-是一个点指向另一个点的方向" aria-hidden="true">#</a> 向量(vectors),是一个点指向另一个点的方向</h2><p>$$ \\vec{AB} = B - A $$</p><h3 id="任何表示的长度为1个单位的向量我们称为单位向量-等于向量-向量的长度" tabindex="-1"><a class="header-anchor" href="#任何表示的长度为1个单位的向量我们称为单位向量-等于向量-向量的长度" aria-hidden="true">#</a> 任何表示的长度为1个单位的向量我们称为单位向量，等于向量/向量的长度</h3><p>$$ \\hat{AB} = \\vec{AB}/||\\vec{AB}|| $$</p><figure><img src="'+p+'" alt="向量相加" tabindex="0" loading="lazy"><figcaption>向量相加</figcaption></figure><h3 id="将向量引入到坐标系中表示为" tabindex="-1"><a class="header-anchor" href="#将向量引入到坐标系中表示为" aria-hidden="true">#</a> 将向量引入到坐标系中表示为</h3><p>$$<br> \\vec{a} = \\begin{pmatrix} x \\ y \\ \\end{pmatrix}<br> \\qquad<br> \\vec{a}^T = \\begin{pmatrix} x &amp; y \\ \\end{pmatrix}<br> \\qquad<br> ||\\vec{a}|| = \\sqrt{x<sup>2+y</sup>2}<br> $$</p><h3 id="向量的乘法" tabindex="-1"><a class="header-anchor" href="#向量的乘法" aria-hidden="true">#</a> 向量的乘法</h3><ul><li>向量的点乘<br> $$ \\vec{a} . \\vec{b} = ||\\vec{a}||||\\vec{b}||cos\\theta $$<br> 这可以帮助我们快速的确定两个向量之间的夹角$cos\\theta$<br> $$ cos\\theta = \\hat{a}.\\hat{b} $$<br> 作用：</li></ul><ol><li>当点乘结果逐渐趋向1时，我们可以知道这两个向量的方向越接近</li><li>当点乘结果为0时，我们可以知道这两个向量的方向互相垂直</li><li>当点乘结果逐渐趋向-1时，我们可以知道这两个向量的方向相反</li></ol><p>它满足运算的交换率，与结合率<br> $$ \\vec{a} . \\vec{b} = \\vec{b} . \\vec{a} \\qquad \\vec{a} . (\\vec{b}+\\vec{c}) =\\vec{a} . \\vec{b} + \\vec{a} . \\vec{c} $$</p><ul><li>向量的叉乘<br> $$ \\vec{a} \\times \\vec{b} = ||\\vec{a} \\times \\vec{b}|| = ||\\vec{a}||||\\vec{b}||sin\\phi$$</li></ul><p>在三维坐标系中(右手坐标系中)<br> $$ \\vec{x} \\times \\vec{y} = +\\vec{z}<br> $$</p><p>叉乘没有交换率<br> $$ \\vec{a} \\times \\vec{b} = -\\vec{b} \\times \\vec{a}<br> $$</p><p>作用:</p><ol><li>利用向量叉乘我们可以判断一个向量在另一个向量的左侧还是右侧</li><li>可以判断一个点在一个多边形点内侧还是外侧</li></ol><h1 id="矩阵" tabindex="-1"><a class="header-anchor" href="#矩阵" aria-hidden="true">#</a> 矩阵</h1><h3 id="矩阵的乘积" tabindex="-1"><a class="header-anchor" href="#矩阵的乘积" aria-hidden="true">#</a> 矩阵的乘积</h3><p>必须满足$(M \\times N)(N \\times P) = (M \\times P)$</p>',21),m=a("h1",{pmatrix:"",id:"矩阵的乘积的结果中的单个目标等于矩阵a的行与矩阵b的列的元素分别相乘在并将元素相加-begin-pmatrix-a1-a2-b1-b2-c1-c2-end-pmatrix-begin-pmatrix-a1-a2-b1-b2-end",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#矩阵的乘积的结果中的单个目标等于矩阵a的行与矩阵b的列的元素分别相乘在并将元素相加-begin-pmatrix-a1-a2-b1-b2-c1-c2-end-pmatrix-begin-pmatrix-a1-a2-b1-b2-end","aria-hidden":"true"},"#"),e(" 矩阵的乘积的结果中的单个目标等于矩阵A的行与矩阵B的列的元素分别相乘在并将元素相加"),a("br"),e(" $$"),a("br"),e(" \\begin{pmatrix}"),a("br"),e(" a1 & a2\\"),a("br"),e(" b1 & b2\\"),a("br"),e(" c1 & c2\\"),a("br"),e(" \\end{pmatrix}"),a("br"),e(" \\begin{pmatrix}"),a("br"),e(" A1 & A2\\"),a("br"),e(" B1 & B2\\"),a("br"),e(" \\end")],-1),d=r('<p>\\begin{pmatrix}<br> a1 \\times A1 + a2 \\times B1 &amp; a1 \\times A2 + a2 \\times B2\\ b1 \\times A1 + b2 \\times B1 &amp; b1 \\times A2 + b2 \\times B2\\ c1 \\times A1 + c2 \\times B1 &amp; c1 \\times A2 + c2 \\times B2\\ \\end{pmatrix}<br> $$</p><h1 id="只有对角线为1-其他元素为0对矩阵为单位矩阵-i-3-times-3" tabindex="-1"><a class="header-anchor" href="#只有对角线为1-其他元素为0对矩阵为单位矩阵-i-3-times-3" aria-hidden="true">#</a> 只有对角线为1，其他元素为0对矩阵为单位矩阵<br> $$<br> I_{3 \\times 3}</h1><p>\\begin{pmatrix}<br> 1&amp;0&amp;0\\<br> 0&amp;1&amp;0\\<br> 0&amp;0&amp;1\\<br> \\end{pmatrix}<br> $$</p><h2 id="向量的点乘" tabindex="-1"><a class="header-anchor" href="#向量的点乘" aria-hidden="true">#</a> 向量的点乘</h2>',4),s=a("h1",{b:"",id:"vec-a-vec",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#vec-a-vec","aria-hidden":"true"},"#"),e(" $$"),a("br"),e(" \\vec{a}.\\vec")],-1),c=a("h1",{b:"",id:"vec-a-t-vec",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#vec-a-t-vec","aria-hidden":"true"},"#"),e(" \\vec{a}^T\\vec")],-1),x=a("h1",{pmatrix:"",id:"begin-pmatrix-x-a-y-a-z-a-end-pmatrix-begin-pmatrix-x-b-y-b-z-b-end",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#begin-pmatrix-x-a-y-a-z-a-end-pmatrix-begin-pmatrix-x-b-y-b-z-b-end","aria-hidden":"true"},"#"),e(" \\begin{pmatrix} x_a&y_a&z_a \\end{pmatrix}"),a("br"),e(" \\begin{pmatrix} x_b \\ y_b \\ z_b \\end")],-1),$=a("p",null,[e("(x_ax_b+y_zy_b+z_az_b)"),a("br"),e(" $$")],-1),o=a("h2",{id:"向量的叉乘",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#向量的叉乘","aria-hidden":"true"},"#"),e(" 向量的叉乘")],-1),_=a("h1",{b:"",id:"vec-a-times-vec",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#vec-a-times-vec","aria-hidden":"true"},"#"),e(" $$"),a("br"),e(" \\vec{a} \\times \\vec")],-1),l=r('<p>\\begin{pmatrix}<br> 0 &amp; -z_a &amp; y_a \\<br> z_a &amp; 0 &amp; -x_a \\<br> -y_z &amp; x_z &amp; 0<br> \\end{pmatrix}<br> \\begin{pmatrix} x_b \\ y_b \\ z_b \\end{pmatrix}<br> $$</p><h3 id="矩阵的变换" tabindex="-1"><a class="header-anchor" href="#矩阵的变换" aria-hidden="true">#</a> 矩阵的变换</h3><ul><li><h1 id="缩放-scale-sa" tabindex="-1"><a class="header-anchor" href="#缩放-scale-sa" aria-hidden="true">#</a> 缩放(scale)<br> $$<br> SA</h1><p>\\begin{pmatrix}<br> s_x &amp; 0 &amp; 0\\<br> 0 &amp; s_y &amp; 0 \\<br> 0 &amp; 0 &amp; s_z<br> \\end{pmatrix}<br> \\begin{pmatrix} x \\ y \\ z \\end{pmatrix}<br> $$</p></li><li><h1 id="切变-shear-sa" tabindex="-1"><a class="header-anchor" href="#切变-shear-sa" aria-hidden="true">#</a> 切变(shear)<br> $$<br> SA</h1><p>\\begin{pmatrix} 1 &amp; s_y \\ s_x &amp; 1 \\end{pmatrix}<br> \\begin{pmatrix} x \\ y \\end{pmatrix}<br> $$</p></li><li><h1 id="旋转-retition-r-theta" tabindex="-1"><a class="header-anchor" href="#旋转-retition-r-theta" aria-hidden="true">#</a> 旋转(Retition)<br> $$<br> R_\\theta</h1><h1 id="begin-pmatrix-cos-theta-sin-theta-sin-theta-cos-theta-end-pmatrix-r-theta" tabindex="-1"><a class="header-anchor" href="#begin-pmatrix-cos-theta-sin-theta-sin-theta-cos-theta-end-pmatrix-r-theta" aria-hidden="true">#</a> \\begin{pmatrix} cos\\theta &amp; -sin\\theta \\ sin\\theta &amp; cos\\theta \\end{pmatrix}<br> $$<br> $$<br> R^-_\\theta</h1><p>\\begin{pmatrix} cos\\theta &amp; sin\\theta \\ -sin\\theta &amp; cos\\theta \\end{pmatrix}<br> $$</p></li></ul><h1 id="奇次坐标" tabindex="-1"><a class="header-anchor" href="#奇次坐标" aria-hidden="true">#</a> 奇次坐标</h1><p>在平移变换中我们无法使用线性变换的法制进行转换<br> $$<br> TA =<br> \\begin{pmatrix}a &amp; b \\ c &amp; d \\end{pmatrix}<br> \\begin{pmatrix}x \\ y \\end{pmatrix}<br> +<br> \\begin{pmatrix}t_x\\ t_y \\end{pmatrix}<br> $$<br> 这时我们添加一个坐标 w 用来将它同化为线性变换</p>',5),g=a("h1",{pmatrix:"",id:"ta-begin-pmatrix-1-0-t-x-0-1-t-y-0-0-1-end-pmatrix-begin-pmatrix-x-y-w-end",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#ta-begin-pmatrix-1-0-t-x-0-1-t-y-0-0-1-end-pmatrix-begin-pmatrix-x-y-w-end","aria-hidden":"true"},"#"),e(" $$"),a("br"),e(" TA ="),a("br"),e(" \\begin{pmatrix}1 & 0 & t_x\\ 0 & 1 & t_y \\ 0 & 0 & 1\\end{pmatrix}"),a("br"),e(" \\begin{pmatrix}x \\ y \\ w\\end")],-1),v=r('<p>\\begin{pmatrix}x+xt_x\\ y+yt_y \\ w^2\\end{pmatrix}<br> $$<br> 当$w \\neq 0$时这是点坐标<br> $$<br> P = \\begin{pmatrix}x / w &amp; y / w &amp; 1 \\end{pmatrix}<br> $$</p><p>当$w = 0$时这是向量<br> $$<br> V = \\begin{pmatrix}x &amp; y &amp; 0 \\end{pmatrix}<br> $$</p><h2 id="奇次坐标在三维中的转换" tabindex="-1"><a class="header-anchor" href="#奇次坐标在三维中的转换" aria-hidden="true">#</a> 奇次坐标在三维中的转换</h2>',3),u=a("h1",{pmatrix:"",id:"begin-pmatrix-x-prime-y-prime-z-prime-w-end",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#begin-pmatrix-x-prime-y-prime-z-prime-w-end","aria-hidden":"true"},"#"),e(" $$"),a("br"),e(" \\begin{pmatrix} x^\\prime \\ y^\\prime \\ z^\\prime \\ w \\end")],-1),y=r('<p>\\begin{pmatrix}<br> a &amp; b &amp; c &amp; t_x \\<br> d &amp; e &amp; f &amp; t_y \\<br> g &amp; h &amp; i &amp; t_z \\<br> 0 &amp; 0 &amp; 0 &amp; 1<br> \\end{pmatrix}<br> .<br> \\begin{pmatrix} x \\ y \\ z \\ w \\end{pmatrix}<br> $$</p><p>Scale</p><h1 id="s-s-x-s-y-s-z" tabindex="-1"><a class="header-anchor" href="#s-s-x-s-y-s-z" aria-hidden="true">#</a> $$<br> S(s_x,s_y,s_z)</h1><p>\\begin{pmatrix}<br> s_x &amp; 0 &amp; 0 &amp; 0 \\<br> 0 &amp; s_y &amp; 0 &amp; 0 \\<br> 0 &amp; 0 &amp; s_z &amp; 0 \\<br> 0 &amp; 0 &amp; 0 &amp; 1<br> \\end{pmatrix}<br> $$</p><h1 id="translation-t-t-x-t-y-t-z" tabindex="-1"><a class="header-anchor" href="#translation-t-t-x-t-y-t-z" aria-hidden="true">#</a> Translation<br> $$<br> T(t_x,t_y,t_z)</h1><p>\\begin{pmatrix}<br> 1 &amp; 0 &amp; 0 &amp; t_x \\<br> 0 &amp; 1 &amp; 0 &amp; t_y \\<br> 0 &amp; 0 &amp; 1 &amp; t_z \\<br> 0 &amp; 0 &amp; 0 &amp; 1<br> \\end{pmatrix}<br> $$</p><p>Rotation</p><h1 id="r-x-theta" tabindex="-1"><a class="header-anchor" href="#r-x-theta" aria-hidden="true">#</a> $$<br> R_x(\\theta)</h1><h1 id="begin-pmatrix-1-0-0-0-0-cos-theta-sin-theta-0-0-sin-theta-cos-theta-0-0-0-0-1-end-pmatrix-r-y-theta" tabindex="-1"><a class="header-anchor" href="#begin-pmatrix-1-0-0-0-0-cos-theta-sin-theta-0-0-sin-theta-cos-theta-0-0-0-0-1-end-pmatrix-r-y-theta" aria-hidden="true">#</a> \\begin{pmatrix}<br> 1 &amp; 0 &amp; 0 &amp; 0 \\<br> 0 &amp; cos\\theta &amp; -sin\\theta &amp; 0 \\<br> 0 &amp; sin\\theta &amp; cos\\theta &amp; 0 \\<br> 0 &amp; 0 &amp; 0 &amp; 1<br> \\end{pmatrix}<br> $$<br> $$<br> R_y(\\theta)</h1><h1 id="begin-pmatrix-cos-theta-0-sin-theta-0-0-1-0-0-sin-theta-0-cos-theta-0-0-0-0-1-end-pmatrix-r-z-theta" tabindex="-1"><a class="header-anchor" href="#begin-pmatrix-cos-theta-0-sin-theta-0-0-1-0-0-sin-theta-0-cos-theta-0-0-0-0-1-end-pmatrix-r-z-theta" aria-hidden="true">#</a> \\begin{pmatrix}<br> cos\\theta &amp; 0 &amp; sin\\theta &amp; 0 \\<br> 0 &amp; 1 &amp; 0 &amp; 0 \\<br> -sin\\theta &amp; 0 &amp; cos\\theta &amp; 0 \\<br> 0 &amp; 0 &amp; 0 &amp; 1<br> \\end{pmatrix}<br> $$<br> $$<br> R_z(\\theta)</h1><p>\\begin{pmatrix}<br> cos\\theta &amp; -sin\\theta &amp; 0 &amp; 0 \\<br> sin\\theta &amp; cos\\theta &amp; 0 &amp; 0 \\<br> 0 &amp; 0 &amp; 1 &amp; 0\\<br> 0 &amp; 0 &amp; 0 &amp; 1<br> \\end{pmatrix}<br> $$</p><h2 id="罗德里格斯公式" tabindex="-1"><a class="header-anchor" href="#罗德里格斯公式" aria-hidden="true">#</a> 罗德里格斯公式</h2><p>$$<br> R(n,\\alpha)=<br> cos(\\alpha)I +<br> (1-cos(\\alpha))nn^T +<br> sin(\\alpha)N<br> $$<br> 其中<br> $$<br> n = 旋转的轴向量（过原点）<br> \\qquad<br> \\alpha = 旋转的角度<br> $$<br> $$<br> n^T = n的转置<br> \\qquad<br> N =<br> \\begin{pmatrix}<br> 0 &amp; -n_z &amp; n_y \\<br> n_z &amp; 0 &amp; -n_x \\<br> -n_y &amp; n_x &amp; 0<br> \\end{pmatrix}<br> \\qquad<br> I = 单位矩阵<br> $$</p>',13),f=[h,m,d,s,c,x,$,o,_,l,g,v,u,y];function z(A,B){return i(),b("div",null,f)}const T=t(n,[["render",z],["__file","01.linearAlgebra.html.vue"]]);export{T as default};
